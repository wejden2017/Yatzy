1. Fichier: modules/nlb/main.tf
Modifiez le fichier pour remplacer tout ce qui concerne les listeners et règles de listener par :
hcl# === Target group catsweb (port 8080, TCP) === 
resource "aws_lb_target_group" "tg_cats_web" {
  name        = "${var.entity}-${var.application}-${var.environment}-cats-web-tg"
  port        = 8080
  protocol    = "TCP"  # Changé de HTTP à TCP
  vpc_id      = var.vpc_id
  target_type = "instance"
  tags        = var.tags
  
  health_check {
    path                = "/"
    port                = 8080
    protocol            = "HTTP"  # Health check peut rester en HTTP
    interval            = 30
    timeout             = 5
    healthy_threshold   = 3
    unhealthy_threshold = 3
    matcher             = "200"
  }
}

# === Target group catsbackend (port 8081, TCP) === 
resource "aws_lb_target_group" "tg_cats_backend" {
  name        = "${var.entity}-${var.application}-${var.environment}-cats-backend-tg"
  port        = 8081
  protocol    = "TCP"  # Changé de HTTP à TCP
  vpc_id      = var.vpc_id
  target_type = "instance"
  tags        = var.tags
  
  health_check {
    path                = "/"
    port                = 8081
    protocol            = "HTTP"  # Health check peut rester en HTTP
    interval            = 30
    timeout             = 5
    healthy_threshold   = 3
    unhealthy_threshold = 3
    matcher             = "200"
  }
}

# === Listener pour le service web (port 80) ===
resource "aws_lb_listener" "web_listener" {
  load_balancer_arn = aws_lb.nlb_cats.arn
  port              = 80
  protocol          = "TCP"
  
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.tg_cats_web.arn
  }
}

# === Listener pour le service backend (port 81) ===
resource "aws_lb_listener" "backend_listener" {
  load_balancer_arn = aws_lb.nlb_cats.arn
  port              = 81
  protocol          = "TCP"
  
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.tg_cats_backend.arn
  }
}

# Supprimez toutes les ressources aws_lb_listener_rule si elles existent
2. Fichier: modules/nlb/outputs.tf
Modifiez pour ajouter les sorties des ARNs des listeners :
hcloutput "web_listener_arn" {
  description = "ARN of the web listener"
  value       = aws_lb_listener.web_listener.arn
}

output "backend_listener_arn" {
  description = "ARN of the backend listener"
  value       = aws_lb_listener.backend_listener.arn
}
3. Fichier: modules/api_gateway_http/variables.tf
Modifiez pour remplacer nlb_listener_arn par deux variables distinctes :
hclvariable "web_listener_arn" {
  description = "ARN of the NLB listener for web service"
  type        = string
}

variable "backend_listener_arn" {
  description = "ARN of the NLB listener for backend service"
  type        = string
}

# Conservez les autres variables existantes
4. Fichier: modules/api_gateway_http/main.tf
Modifiez les ressources d'intégration :
hcl# === Integration pour catsweb ===
resource "aws_apigatewayv2_integration" "catsweb" {
  api_id               = aws_apigatewayv2_api.this.id
  integration_type     = "HTTP_PROXY"
  integration_uri      = var.web_listener_arn  # Utilisez le listener web (port 80)
  integration_method   = "ANY"
  connection_type      = "VPC_LINK"
  connection_id        = var.vpc_link_id
  payload_format_version = "1.0"
}

# === Integration pour catsbackend ===
resource "aws_apigatewayv2_integration" "catsbackend" {
  api_id               = aws_apigatewayv2_api.this.id
  integration_type     = "HTTP_PROXY"
  integration_uri      = var.backend_listener_arn  # Utilisez le listener backend (port 81)
  integration_method   = "ANY"
  connection_type      = "VPC_LINK"
  connection_id        = var.vpc_link_id
  payload_format_version = "1.0"
}

# Conservez les autres ressources (routes, stage, etc.)
5. Fichier: terraform/main.tf (ou votre fichier principal)
Modifiez l'appel au module api_gateway_http :
hclmodule "api_gateway_http" {
  source              = "./modules/api_gateway_http"
  name_prefix         = "${var.entity}-${var.application}-${var.environment}-front-api-gateway"
  vpc_link_id         = module.vpc_link_cats.http_vpc_link_id
  web_listener_arn    = module.nlb_cats_front.web_listener_arn     # Remplacez nlb_listener_arn
  backend_listener_arn = module.nlb_cats_front.backend_listener_arn # Ajoutez cette ligne
  nlb_dns_name        = module.nlb_cats_front.nlb_dns_name
  environment         = var.environment
  common_tags         = local.standard_tags
  tags                = { Role = "CATS-API-GATEWAY-HTTP" }
  
  # Conservez les autres paramètres existants, mais retirez catsweb_tg_arn et catsbackend_tg_arn
  # s'ils sont présents car nous n'en avons plus besoin
}

Points de vérification
Avant de déployer, vérifiez les points suivants :

Network Load Balancer (NLB):

A deux listeners sur les ports 80 et 81 en protocole TCP
A deux target groups en protocole TCP mais avec health check HTTP
Les target groups pointent correctement vers les ports 8080 et 8081 de vos instances


API Gateway HTTP:

Utilise le VPC Link pour se connecter au NLB
A deux routes pour /catsweb et /catsbackend
Les intégrations utilisent les ARNs corrects des listeners NLB


Variables et Outputs:

Tous les outputs nécessaires sont définis dans les modules
Toutes les variables nécessaires sont déclarées et passées correctement



Cette configuration permettra à votre API Gateway HTTP de router les requêtes vers les bons services sans exposer directement les ports.
Si vous rencontrez d'autres erreurs, n'hésitez pas à me les partager pour obtenir de l'aide supplémentaire.
